const puzzleInput = [
    '#################################################################################',
    '#...#.......#.....#.......#...#.........#.......#.......#..q............#...#...#',
    '#.#.#.#.###.###.#.#.#####.#.#.#.#######.#####.#.###.###Y###.#######.#####I#.#.#.#',
    '#.#.#.#...#.....#.#.....#.#.#...#...#...#.....#.....#.#.....#.......#...#.#...#.#',
    '#.#.#####.#######.#####.#.#.#####.#.#.#.#.#####.#####.###.#######.###N#.#.#####.#',
    '#.#....f#.....#.#.#.#...#.#...#...#...#.#...#...#...#...#.#.....#.#...#.#...#...#',
    '#.#####.###.#.#.#.#.#.###.#####.###########.#####.#.#.###.#.###.###.###.###.#.###',
    '#.....#...#.#.#.#...#...#.....#.#.......#...#...#.#.#.....#.#.#.......#.....#.F.#',
    '#####.###.###.#.###.###.#####.#.#.#####.#.###.#.#.#.#######.#.#############.###.#',
    '#...#.#.#.#...#.....#.....#...#.#...#...#...#.#.#.#.......#.#.....#.......#.#a..#',
    '#.#.#.#.#.#.###.#####.#####.###.#.###.#.#.#.#.#.#.#######.#.#.#.###.#####.###.###',
    '#.#...#.#...#.#...#...#.....#...#.#...#.#.#...#.#.....#...#.#.#...#.....#.....#.#',
    '#.#####.#####.#.###.###.#######.#.#.###.#######.#.#####.#.#.#####.#####.#######.#',
    '#...#.........#.#...#.#.......#...#.#.#.#.....#...#...#.#.#...........#.#.......#',
    '###.#########.#.#.###.#######.#.###.#.#.#.###.#####.#.#.###########.###.#.#####.#',
    '#...#.....#...#.#.......#...#.#.#...#.#.#.#.....#...#...#...#.......#...#...#...#',
    '#.#.#.###.#.###.#######.#.###.#.#.###.#.#.#####.#.#####.#.#.#.#######.#####.#####',
    '#.#.#...#.#.....#.#.......#...#.#.#.#...#...#.....#.....#.#.......#...#...#.....#',
    '#.#####.#.###.###.#.#######.#####.#.#.###.#.#########.###.#########.###.#.#####.#',
    '#.......#...#.....#.#.......#.....#...#.#.#.....#...#.#.#...#.....#.#...#.......#',
    '#.#######.#.#######.#.#########.###.###.#.#####.#.#.#.#.###.#.###.#.#.#.#######.#',
    '#...#...#.#.......#.#.#...L...#.#.#...#.#...#.#...#.#.....#.#.#.#.#.#.#...#...#.#',
    '#.###.#.#####.###.#.#######.#.#.#.###.#.###.#.#####.#####.#.###.#.#.#####.#.#.###',
    '#.#...#.....#...#.#.......#.#...#.......#.#.......#...#...#.#...#...#.....#.#...#',
    '#.#.#######.###.#.#######.#.###########.#.#######.###.#.###.#.#.#####.#.###.###.#',
    '#.#.#.#.....#...#...#.....#.........#...#.#...#.....#.#...#.#.#.....#.#.#...#.#.#',
    '###.#.#.#########.###.###########.#.###.#.#.#.#.#####.###.#.#####.#.#.###.###.#.#',
    '#...#...J.#.......#...#.........#.#...#.#...#...#.....#.#.#.#.....#...#...#s..#.#',
    '#.#######.#.#####S#.#######.###.#.###.###.#######.#####.#.#.#.#####.###.#####.#.#',
    '#.#.....#...#...#.#.#.....#.#.#.#...#...#...#.#...#.......#.#...#...#...#.....#.#',
    '#.#T###.#####.#.###.###.#.#.#.#.#.#####.###.#.#.#########.#.###.#####.###.#####.#',
    '#.#.#...#.....#.#...#...#...#...#.#...#.#.#.#.#.#.......#.#...#.......#.....#..w#',
    '#.#.#.###.#####.#.###.#######.#####.#.#.#.#.#.#.#.#####.#####.#.###########.#.#.#',
    '#...#.#.B.#...#.#.#.#...#.#...#.....#.#.#.#.#.#.#.#r..#.....#.#.#...#.......#.#.#',
    '#.###.#.###.#.#.#.#.#.#.#.#.###.#####.#.#.#.#.#.#.#.#######.#.#.#.#.#.###.###.#.#',
    '#...#.#...#.#.#...#...#.#.#.#.......#...#.#...#...#.......#.#.#.#.#.#.#...#...#.#',
    '###.#.###.###.#########.#.#.#.#####.#####.###.#####.#####.#.#.#.#.#.#.#####.###.#',
    '#...#...#...#.....W...#.#.#.#c#...#.....#...#.....#.#.....#...#...#...#...#...#.#',
    '#.###.#####.###.#####.#.#.#.###.#.#####.#.#.#####.###.###.#############.#.###.#.#',
    '#o..#...........#.......#.......#.........#...........#.................#.....#.#',
    '#######################################.@.#######################################',
    '#...#.....#...#.........#.............#...........#.....#............j....#...#.#',
    '#.#.#P###.###.#.###.###.#.###.#######.#.#.#####.###.#.#.###.#.###.#######.#.#.#.#',
    '#.#...#.#...#.#.#.#...#.#...#.#.....#.#.#.#...#.....#.#...#.#.#...#..t..#...#...#',
    '#G#####.###.#.#.#.###.#.#.###.#.#.#.#.#.#.###.#######.###C###.#.###.###.###.#####',
    '#.#...#...#.#.#.....#.#.#.#...#.#.#.#.#.#...#.....#...#.#...#.#.#...#...#...#...#',
    '#.#.###.#.#.#.#####.#.#.###.#####.###.#.###.#.#####.###.###.#.###.###.#######.#.#',
    '#.#.....#.#.#...#...#.#...#.....#...#.#.#.....#...#.#.....#.#.......#.#.......#.#',
    '#.#######.#.#.###.###.###.#####.###.#.#.#.#####.#.#.#.#####.#.#####.#.#.#######.#',
    '#.......#...#...#.#.#.#.#.....#...#...#.#...#...#.#.#.....#.#.#...#.#...#.......#',
    '#.#####.#.#####.#.#.#.#.#####.###.#.###.#.###.###.#.#####.#.###.#.#######.#####.#',
    '#.#...#.#.....#...#.#.#.....#.....#.#...#.#...#.#.#.....#...#...#.........#.....#',
    '#.#.#.#.#####.#.###.#.#####.#######.#.#.#.#.###.#.#.###.#.###.#############.#####',
    '#...#.#.#.....#.....#.....#...#.....#.#.#.#.#.....#.#.#.#.#...#...#.O.#...#b..#.#',
    '#####.#.###.###.#########.###.#.#####.#.#.#.#.#####.#.#.#.#.###.#.###.#.#.###.#.#',
    '#...#.#...#...#.#.........#...#...#...#.#.#.#...#.....#.#...#...#..d#.#.#...#.#.#',
    '#.###.###.###.#.#.#########.#.###.#.###.###.###.#######.###.#.#####.#.#.#.###.#.#',
    '#.#.X.#.#.#...#.#...#.#.....#...#.#...#.#...#.....#.....#...#.#...#.#...#...#...#',
    '#.#.###.#.#.###.###.#.#.###.###.#.#.#.#.#.#.#####.#.#####.###.###.#.#######.###.#',
    '#.......#.#.#.#...#.#...#.#.#...#.#.#.#.#.#.#...#.#.#...#...#...#k#.......#...#.#',
    '#.#####.#.#.#.#.###.###.#.#.#####.#.#.###.###.#.#.#.#.#.#######.#.#######.#.#.#.#',
    '#.#...#.#.#.#...#...#.#...#.#...#.#.#...#.#...#.#...#.#.....U.#.#.....#...#.#...#',
    '#.#.#.###.#.#.###.#.#.###.#.#.#.#.#####.#.#.###.###.#.#########.#.#####.#########',
    '#.#.#.....#.#.#...#.#.#...#...#...#...#.#.....#...#.#...#......h#.......#.......#',
    '#.#.#######.###.###.#.#######.#####.#.#.#########.#.###.###.#####.#######.#####.#',
    '#.#.#...#.....#.#...#u......#...#...#.R.#.......#.#.#...#...#...#........x#...#.#',
    '#.#.#.#.#####.#.#.#########.###.#.#.###.#.#####.#.###.###.###.#Z###########.#.#.#',
    '#.#...#...#.#...#...#...#.E.#.#.#.#.#...#...#...#...#.#.......#.#.....#....g#.#.#',
    '#K#######.#.#####.###.#.#.###.#.#.#.#.#####.#.#####.#.#####.###.#.###.###.#####.#',
    '#.#z....#.#.......#..v#.#...#.#.#.#.#...#...#.....#.#.#..e#...#.#...#...#.......#',
    '#.#.###.#.#########.###.###.#.#.#.#.###.#.#######.#.#.#.#.###.#.#.#####.#.#######',
    '#.#.#...#.......#...#.#.....#.#.#.#.#...#...#.......#...#...#.#...#...M.#.......#',
    '#.###H#.#######.#.###.#######.#.###.#.###.#.###############V#######.###########.#',
    '#...#.#.#.....#.#.....#.........#...#l#.#.#...#.........Q.#.........#.......#...#',
    '###.#.###.#.###.#####.#.#####.###.###.#.#####.#.#######.#############.#####.#.###',
    '#.#.#.....#.#.....#.#.#.#...#...#.#.....#.....#.#...#...#.......#.........#.#..p#',
    '#.#.#######.#.###.#.#.###.#.###.#.#####.#.###.#.###.#.###.###.#.#.#######.#.###.#',
    '#.#...D.....#.#.....#m....#.#...#...#.#.#y#...#.#...#n..#...#i#.#.#.......#.#...#',
    '#.#########.#.#############.#.#####.#.#.#.#####.#.#.###.###.#.###.#.#########.###',
    '#...........#...............#.......#...#.........#...#.....#.....#.......A.....#',
    '#################################################################################',
]


const testInput = [
    '########################',
    '#f.D.E.e.C.b.A.@.a.B.c.#',
    '######################.#',
    '#d.....................#',
    '########################',
]


const anotherTestInput = [
    '#################',
    '#i.G..c...e..H.p#',
    '########.########',
    '#j.A..b...f..D.o#',
    '########@########',
    '#k.E..a...g..B.n#',
    '########.########',
    '#l.F..d...h..C.m#',
    '#################',
]

const tiles = anotherTestInput.map(inputString => inputString.split(''))

const getStartingPosition = (targetArray, findSymbol) => {
    const yPos = targetArray.findIndex(val => val.includes(findSymbol))
    const xPos = targetArray[yPos].findIndex(val => val === findSymbol)

    return [yPos, xPos]
}

let reachableObjects = []

const getReachableObjects = (startPosition, prevPosition = [-1, -1], keys = [], reachableObjects = [], deep = 0, visited = {}) => {

    if (visited[`${startPosition[0]},${startPosition[1]}`]) {
        return
    }

    

    visited[`${startPosition[0]},${startPosition[1]}`] = 1

    const [yPos, xPos] = startPosition;
    const [yPrevPos, xPrevPos] = prevPosition

    const occupied = {
        UP: () => tiles[yPos - 1] && tiles[yPos - 1][xPos],
        DOWN: () => tiles[yPos + 1] && tiles[yPos + 1][xPos],
        LEFT: () => tiles[yPos] && tiles[yPos][xPos - 1],
        RIGHT: () => tiles[yPos] && tiles[yPos][xPos + 1],
    }

    const coordinates = {
        UP: () => [yPos - 1, xPos],
        DOWN: () => [yPos + 1, xPos],
        LEFT: () => [yPos, xPos - 1],
        RIGHT: () => [yPos, xPos + 1],
    }


    for (const direction in occupied) {
        const [dirY, dirX] = coordinates[direction]()
        if (dirX === xPrevPos && dirY === yPrevPos) {
            continue
        }

        const found = occupied[direction]()
        if (found === '#') { continue }
        if (found.match(/[a-z]/i)) {
            if (found === found.toUpperCase()) {

                // console.log("DOOR ", found, " KEYS ", keys, " CAN OPEN ", keys.includes(found.toLowerCase()))

                if (keys.includes(found.toLowerCase())) {
                    getReachableObjects(coordinates[direction](), startPosition, keys, reachableObjects, deep + 1, visited)
                }
            }
            if (found === found.toLowerCase()) {
                if (!keys.includes(found)) {
                    reachableObjects.push(found)
                }
                else {
                    
                    getReachableObjects(coordinates[direction](), startPosition, keys, reachableObjects, deep + 1, visited)
                }
            }
        }
        if (found === '.' || found === '@') {
            getReachableObjects(coordinates[direction](), startPosition, keys, reachableObjects, deep + 1, visited)
        }
    }

    return reachableObjects

}

const getShortestDistanceTo = (startPosition, prevPosition = [-1, -1], deep = 0, visited = {}, target, solutions = []) => {

    if (deep > 500) return

    visited[`${startPosition[0]},${startPosition[1]}`] = 1

    const [yPos, xPos] = startPosition;
    const [yPrevPos, xPrevPos] = prevPosition

    const occupied = {
        UP: () => tiles[yPos - 1] && tiles[yPos - 1][xPos],
        DOWN: () => tiles[yPos + 1] && tiles[yPos + 1][xPos],
        LEFT: () => tiles[yPos] && tiles[yPos][xPos - 1],
        RIGHT: () => tiles[yPos] && tiles[yPos][xPos + 1],
    }

    const coordinates = {
        UP: () => [yPos - 1, xPos],
        DOWN: () => [yPos + 1, xPos],
        LEFT: () => [yPos, xPos - 1],
        RIGHT: () => [yPos, xPos + 1],
    }


    for (const direction in occupied) {
        const [dirY, dirX] = coordinates[direction]()
        if (dirX === xPrevPos && dirY === yPrevPos) {
            continue
        }

        const found = occupied[direction]()

        if (found === target) {
            solutions.push(deep)
        }

        if (found === '#') { continue }

        if (found.match(/[a-z]/i)) {
            getShortestDistanceTo(coordinates[direction](), startPosition, deep + 1, visited, target, solutions)
        }
        if (found === '.' || found === '@') {
            getShortestDistanceTo(coordinates[direction](), startPosition, deep + 1, visited, target, solutions)
        }
    }

    if(solutions.length > 0){
        return solutions.reduce((acc, val) => acc < val ? acc : val)
    }
}

// console.log(getShortestDistanceTo(getStartingPosition(tiles, "@"), [-1,-1], 1, {}, 'p'))

const steps = []

const objectFromStartingPosition = getReachableObjects(getStartingPosition(tiles, "@"), [-1, -1])

const doSomething = (position, target, keys, deep = 1) => {
    const newkeys = [...keys]
    newkeys.push(tiles[position[0]][position[1]])

    const reachableObjects = getReachableObjects(position, [-1, -1], newkeys, [], 0, {})

    if (reachableObjects.length === 0) {
        steps.push(deep)
        return
    }

    reachableObjects.forEach(key => {
        const currentDeep = getShortestDistanceTo(position, [-1, -1], deep, {}, key, [])
        doSomething(getStartingPosition(tiles, key), key, newkeys, currentDeep +1)
    }
    )
}

objectFromStartingPosition.forEach(key => {

   
    const currentDeep = getShortestDistanceTo(getStartingPosition(tiles, "@"), [-1, -1], 1, {}, key, [])
    doSomething(getStartingPosition(tiles, key), key, [], currentDeep)
    console.log(steps.join(' '))
}
)

console.log(steps.reduce((acc, val) => acc < val ? acc : val))
