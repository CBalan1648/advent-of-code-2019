const puzzleInput = [
    '#################################################################################',
    '#...#.......#.....#.......#...#.........#.......#.......#..q............#...#...#',
    '#.#.#.#.###.###.#.#.#####.#.#.#.#######.#####.#.###.###Y###.#######.#####I#.#.#.#',
    '#.#.#.#...#.....#.#.....#.#.#...#...#...#.....#.....#.#.....#.......#...#.#...#.#',
    '#.#.#####.#######.#####.#.#.#####.#.#.#.#.#####.#####.###.#######.###N#.#.#####.#',
    '#.#....f#.....#.#.#.#...#.#...#...#...#.#...#...#...#...#.#.....#.#...#.#...#...#',
    '#.#####.###.#.#.#.#.#.###.#####.###########.#####.#.#.###.#.###.###.###.###.#.###',
    '#.....#...#.#.#.#...#...#.....#.#.......#...#...#.#.#.....#.#.#.......#.....#.F.#',
    '#####.###.###.#.###.###.#####.#.#.#####.#.###.#.#.#.#######.#.#############.###.#',
    '#...#.#.#.#...#.....#.....#...#.#...#...#...#.#.#.#.......#.#.....#.......#.#a..#',
    '#.#.#.#.#.#.###.#####.#####.###.#.###.#.#.#.#.#.#.#######.#.#.#.###.#####.###.###',
    '#.#...#.#...#.#...#...#.....#...#.#...#.#.#...#.#.....#...#.#.#...#.....#.....#.#',
    '#.#####.#####.#.###.###.#######.#.#.###.#######.#.#####.#.#.#####.#####.#######.#',
    '#...#.........#.#...#.#.......#...#.#.#.#.....#...#...#.#.#...........#.#.......#',
    '###.#########.#.#.###.#######.#.###.#.#.#.###.#####.#.#.###########.###.#.#####.#',
    '#...#.....#...#.#.......#...#.#.#...#.#.#.#.....#...#...#...#.......#...#...#...#',
    '#.#.#.###.#.###.#######.#.###.#.#.###.#.#.#####.#.#####.#.#.#.#######.#####.#####',
    '#.#.#...#.#.....#.#.......#...#.#.#.#...#...#.....#.....#.#.......#...#...#.....#',
    '#.#####.#.###.###.#.#######.#####.#.#.###.#.#########.###.#########.###.#.#####.#',
    '#.......#...#.....#.#.......#.....#...#.#.#.....#...#.#.#...#.....#.#...#.......#',
    '#.#######.#.#######.#.#########.###.###.#.#####.#.#.#.#.###.#.###.#.#.#.#######.#',
    '#...#...#.#.......#.#.#...L...#.#.#...#.#...#.#...#.#.....#.#.#.#.#.#.#...#...#.#',
    '#.###.#.#####.###.#.#######.#.#.#.###.#.###.#.#####.#####.#.###.#.#.#####.#.#.###',
    '#.#...#.....#...#.#.......#.#...#.......#.#.......#...#...#.#...#...#.....#.#...#',
    '#.#.#######.###.#.#######.#.###########.#.#######.###.#.###.#.#.#####.#.###.###.#',
    '#.#.#.#.....#...#...#.....#.........#...#.#...#.....#.#...#.#.#.....#.#.#...#.#.#',
    '###.#.#.#########.###.###########.#.###.#.#.#.#.#####.###.#.#####.#.#.###.###.#.#',
    '#...#...J.#.......#...#.........#.#...#.#...#...#.....#.#.#.#.....#...#...#s..#.#',
    '#.#######.#.#####S#.#######.###.#.###.###.#######.#####.#.#.#.#####.###.#####.#.#',
    '#.#.....#...#...#.#.#.....#.#.#.#...#...#...#.#...#.......#.#...#...#...#.....#.#',
    '#.#T###.#####.#.###.###.#.#.#.#.#.#####.###.#.#.#########.#.###.#####.###.#####.#',
    '#.#.#...#.....#.#...#...#...#...#.#...#.#.#.#.#.#.......#.#...#.......#.....#..w#',
    '#.#.#.###.#####.#.###.#######.#####.#.#.#.#.#.#.#.#####.#####.#.###########.#.#.#',
    '#...#.#.B.#...#.#.#.#...#.#...#.....#.#.#.#.#.#.#.#r..#.....#.#.#...#.......#.#.#',
    '#.###.#.###.#.#.#.#.#.#.#.#.###.#####.#.#.#.#.#.#.#.#######.#.#.#.#.#.###.###.#.#',
    '#...#.#...#.#.#...#...#.#.#.#.......#...#.#...#...#.......#.#.#.#.#.#.#...#...#.#',
    '###.#.###.###.#########.#.#.#.#####.#####.###.#####.#####.#.#.#.#.#.#.#####.###.#',
    '#...#...#...#.....W...#.#.#.#c#...#.....#...#.....#.#.....#...#...#...#...#...#.#',
    '#.###.#####.###.#####.#.#.#.###.#.#####.#.#.#####.###.###.#############.#.###.#.#',
    '#o..#...........#.......#.......#.........#...........#.................#.....#.#',
    '#######################################.@.#######################################',
    '#...#.....#...#.........#.............#...........#.....#............j....#...#.#',
    '#.#.#P###.###.#.###.###.#.###.#######.#.#.#####.###.#.#.###.#.###.#######.#.#.#.#',
    '#.#...#.#...#.#.#.#...#.#...#.#.....#.#.#.#...#.....#.#...#.#.#...#..t..#...#...#',
    '#G#####.###.#.#.#.###.#.#.###.#.#.#.#.#.#.###.#######.###C###.#.###.###.###.#####',
    '#.#...#...#.#.#.....#.#.#.#...#.#.#.#.#.#...#.....#...#.#...#.#.#...#...#...#...#',
    '#.#.###.#.#.#.#####.#.#.###.#####.###.#.###.#.#####.###.###.#.###.###.#######.#.#',
    '#.#.....#.#.#...#...#.#...#.....#...#.#.#.....#...#.#.....#.#.......#.#.......#.#',
    '#.#######.#.#.###.###.###.#####.###.#.#.#.#####.#.#.#.#####.#.#####.#.#.#######.#',
    '#.......#...#...#.#.#.#.#.....#...#...#.#...#...#.#.#.....#.#.#...#.#...#.......#',
    '#.#####.#.#####.#.#.#.#.#####.###.#.###.#.###.###.#.#####.#.###.#.#######.#####.#',
    '#.#...#.#.....#...#.#.#.....#.....#.#...#.#...#.#.#.....#...#...#.........#.....#',
    '#.#.#.#.#####.#.###.#.#####.#######.#.#.#.#.###.#.#.###.#.###.#############.#####',
    '#...#.#.#.....#.....#.....#...#.....#.#.#.#.#.....#.#.#.#.#...#...#.O.#...#b..#.#',
    '#####.#.###.###.#########.###.#.#####.#.#.#.#.#####.#.#.#.#.###.#.###.#.#.###.#.#',
    '#...#.#...#...#.#.........#...#...#...#.#.#.#...#.....#.#...#...#..d#.#.#...#.#.#',
    '#.###.###.###.#.#.#########.#.###.#.###.###.###.#######.###.#.#####.#.#.#.###.#.#',
    '#.#.X.#.#.#...#.#...#.#.....#...#.#...#.#...#.....#.....#...#.#...#.#...#...#...#',
    '#.#.###.#.#.###.###.#.#.###.###.#.#.#.#.#.#.#####.#.#####.###.###.#.#######.###.#',
    '#.......#.#.#.#...#.#...#.#.#...#.#.#.#.#.#.#...#.#.#...#...#...#k#.......#...#.#',
    '#.#####.#.#.#.#.###.###.#.#.#####.#.#.###.###.#.#.#.#.#.#######.#.#######.#.#.#.#',
    '#.#...#.#.#.#...#...#.#...#.#...#.#.#...#.#...#.#...#.#.....U.#.#.....#...#.#...#',
    '#.#.#.###.#.#.###.#.#.###.#.#.#.#.#####.#.#.###.###.#.#########.#.#####.#########',
    '#.#.#.....#.#.#...#.#.#...#...#...#...#.#.....#...#.#...#......h#.......#.......#',
    '#.#.#######.###.###.#.#######.#####.#.#.#########.#.###.###.#####.#######.#####.#',
    '#.#.#...#.....#.#...#u......#...#...#.R.#.......#.#.#...#...#...#........x#...#.#',
    '#.#.#.#.#####.#.#.#########.###.#.#.###.#.#####.#.###.###.###.#Z###########.#.#.#',
    '#.#...#...#.#...#...#...#.E.#.#.#.#.#...#...#...#...#.#.......#.#.....#....g#.#.#',
    '#K#######.#.#####.###.#.#.###.#.#.#.#.#####.#.#####.#.#####.###.#.###.###.#####.#',
    '#.#z....#.#.......#..v#.#...#.#.#.#.#...#...#.....#.#.#..e#...#.#...#...#.......#',
    '#.#.###.#.#########.###.###.#.#.#.#.###.#.#######.#.#.#.#.###.#.#.#####.#.#######',
    '#.#.#...#.......#...#.#.....#.#.#.#.#...#...#.......#...#...#.#...#...M.#.......#',
    '#.###H#.#######.#.###.#######.#.###.#.###.#.###############V#######.###########.#',
    '#...#.#.#.....#.#.....#.........#...#l#.#.#...#.........Q.#.........#.......#...#',
    '###.#.###.#.###.#####.#.#####.###.###.#.#####.#.#######.#############.#####.#.###',
    '#.#.#.....#.#.....#.#.#.#...#...#.#.....#.....#.#...#...#.......#.........#.#..p#',
    '#.#.#######.#.###.#.#.###.#.###.#.#####.#.###.#.###.#.###.###.#.#.#######.#.###.#',
    '#.#...D.....#.#.....#m....#.#...#...#.#.#y#...#.#...#n..#...#i#.#.#.......#.#...#',
    '#.#########.#.#############.#.#####.#.#.#.#####.#.#.###.###.#.###.#.#########.###',
    '#...........#...............#.......#...#.........#...#.....#.....#.......A.....#',
    '#################################################################################',
]


const testInput = [
    '########################',
    '#f.D.E.e.C.b.A.@.a.B.c.#',
    '######################.#',
    '#d.....................#',
    '########################',
]


const anotherTestInput = [
    '#################',
    '#i.G..c...e..H.p#',
    '########.########',
    '#j.A..b...f..D.o#',
    '########@########',
    '#k.E..a...g..B.n#',
    '########.########',
    '#l.F..d...h..C.m#',
    '#################',
]

const tiles = anotherTestInput.map(inputString => inputString.split(''))

const getStartingPosition = (targetArray, findSymbol) => {
    const yPos = targetArray.findIndex(val => val.includes(findSymbol))
    const xPos = targetArray[yPos].findIndex(val => val === findSymbol)

    return [yPos, xPos]
}

let currentLowest = 160

const getReachableObjects = (startPosition, prevPosition = [-1, -1], keys = [], reachableObjects = [], deep = 1, visited = {}) => {
    

    if(deep > currentLowest){
        return
    }

    if (visited[`${startPosition[0]},${startPosition[1]}`]) {
        return
    }

    

    visited[`${startPosition[0]},${startPosition[1]}`] = 1

    const [yPos, xPos] = startPosition;
    const [yPrevPos, xPrevPos] = prevPosition

    const occupied = {
        UP: () => tiles[yPos - 1] && tiles[yPos - 1][xPos],
        DOWN: () => tiles[yPos + 1] && tiles[yPos + 1][xPos],
        LEFT: () => tiles[yPos] && tiles[yPos][xPos - 1],
        RIGHT: () => tiles[yPos] && tiles[yPos][xPos + 1],
    }

    const coordinates = {
        UP: () => [yPos - 1, xPos],
        DOWN: () => [yPos + 1, xPos],
        LEFT: () => [yPos, xPos - 1],
        RIGHT: () => [yPos, xPos + 1],
    }


    for (const direction in occupied) {
        const [dirY, dirX] = coordinates[direction]()
        if (dirX === xPrevPos && dirY === yPrevPos) {
            continue
        }

        const found = occupied[direction]()
        if (found === '#') { continue }
        if (found.match(/[a-z]/i)) {
            if (found === found.toUpperCase()) {

                // console.log("DOOR ", found, " KEYS ", keys, " CAN OPEN ", keys.includes(found.toLowerCase()))

                if (keys.includes(found.toLowerCase())) {
                    getReachableObjects(coordinates[direction](), startPosition, keys, reachableObjects, deep + 1, visited)
                }
            }
            if (found === found.toLowerCase()) {
                if (!keys.includes(found)) {
                    reachableObjects.push(found)
                }
                else {
                    
                    getReachableObjects(coordinates[direction](), startPosition, keys, reachableObjects, deep + 1, visited)
                }
            }
        }
        if (found === '.' || found === '@') {
            getReachableObjects(coordinates[direction](), startPosition, keys, reachableObjects, deep + 1, visited)
        }
    }

    return reachableObjects

}

const getShortestDistanceTo = (startPosition, prevPosition = [-1, -1], deep = 0, visited = {}, target, solutions = []) => {

    if(deep > currentLowest){
        return
    }

    visited[`${startPosition[0]},${startPosition[1]}`] = 1

    const [yPos, xPos] = startPosition;
    const [yPrevPos, xPrevPos] = prevPosition

    const occupied = {
        UP: () => tiles[yPos - 1] && tiles[yPos - 1][xPos],
        DOWN: () => tiles[yPos + 1] && tiles[yPos + 1][xPos],
        LEFT: () => tiles[yPos] && tiles[yPos][xPos - 1],
        RIGHT: () => tiles[yPos] && tiles[yPos][xPos + 1],
    }

    const coordinates = {
        UP: () => [yPos - 1, xPos],
        DOWN: () => [yPos + 1, xPos],
        LEFT: () => [yPos, xPos - 1],
        RIGHT: () => [yPos, xPos + 1],
    }


    for (const direction in occupied) {
        const [dirY, dirX] = coordinates[direction]()
        if (dirX === xPrevPos && dirY === yPrevPos) {
            continue
        }

        const found = occupied[direction]()

        if (found === target) {
            solutions.push(deep)
        }

        if (found === '#') { continue }

        if (found.match(/[a-z]/i)) {
            getShortestDistanceTo(coordinates[direction](), startPosition, deep + 1, visited, target, solutions)
        }
        if (found === '.' || found === '@') {
            getShortestDistanceTo(coordinates[direction](), startPosition, deep + 1, visited, target, solutions)
        }
    }

    if(solutions.length > 0){
       return solutions.reduce((acc, val) => acc < val ? acc : val)
    }
}

// console.log(getShortestDistanceTo(getStartingPosition(tiles, "@"), [-1,-1], 1, {}, 'p'))

const steps = []

const distances = new Map()

const objectFromStartingPosition = getReachableObjects(getStartingPosition(tiles, "@"), [-1, -1])

const magic = new Array(30).fill(0).map(val => [])

let iterations = 0

const doSomething = (position, target, keys, deep = 1) => {

    // iterations += 1

    // if(iterations > 1000){
    //     if((magic[keys.length].reduce((acc, val) => acc+=val)/magic[keys.length].length)*1.5 < deep){
    //         return
    //     }
    // }

    // magic[keys.length].push(deep)

    if(deep > currentLowest){
        return
    }

    const newkeys = [...keys]
    newkeys.push(tiles[position[0]][position[1]])

    const reachableObjects = getReachableObjects(position, [-1, -1], newkeys, [], 0, {})

    if (reachableObjects.length === 0) {
        if(deep < currentLowest){
            currentLowest = deep
            steps.push(deep)
            console.log(steps[steps.length-1])
        }
        return
    }

    reachableObjects.forEach(key => {
        const cachedDistance = distances.get(`${tiles[position[0]][position[1]]}-${key}`)
        let currentDeep

        if(cachedDistance){
            
            currentDeep = deep+cachedDistance
        }else
        {
            currentDeep = getShortestDistanceTo(position, [-1, -1], deep, {}, key, [])
           
            distances.set(`${tiles[position[0]][position[1]]}-${key}`, currentDeep - deep)
        }

        if(!currentDeep){return}
        doSomething(getStartingPosition(tiles, key), key, newkeys, currentDeep +1)
    }
    )
}

objectFromStartingPosition.forEach(key => {

   
    const currentDeep = getShortestDistanceTo(getStartingPosition(tiles, "@"), [-1, -1], 1, {}, key, [])
    doSomething(getStartingPosition(tiles, key), key, [], currentDeep)
}
)

// console.log("BEST ",steps.reduce((acc, val) => acc < val ? acc : val))
